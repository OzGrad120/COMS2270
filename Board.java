/**
 * @author Osazee Osunde
 * @version 1.2
 */

package hw3;
import java.util.ArrayList;

/**
 * Implements a Board as described in the overview.  A Board represents the
 * current state of the puzzle, containing current tile positions, the cursor
 * position and list of moves the user has made.  For each tile, we also know
 * its starting scrambled coordinates and ending solved coordinates.
 */
public class Board {
	/**
	 * The number of tile rows on the board
	 */
	private int numRows;
	
	/**
	 * The number of tile columns on the board
	 */
	private int numCols;
	
	/**
	 * The current row index of the cursor 
	 */
	private int cursorI;
	
	/**
	 * The current column index of the cursor
	 */
	private int cursorJ;
	
	/**
	 * A two-dimensional array of Tracker objects representing the state of each tile
	 */
	private Tracker[][] trackers;
	
	/**
	 * List of all moves the user made that can be undone
	 */
	private ArrayList<String> moves;
	
	
	
    /**
     * Constructs a 2D (array) board of size numRows by numCols, containing a
     * Tracker in position (i, j) for each tile that is currently in position
     * (i, j) of the unsolved Picture.  Initially, for testing purposes, the
     * scrambled indices and the solved indices of each tile are set to the
     * same value (i, j), and this is stored in position (i, j) as if the
     * puzzle is already solved and there is nothing to do.
     *
     * It also initializes the position of the cursor to be at (0, 0), and
     * allocates an empty ArrayList of Strings to contain everything the user
     * has done which has not been removed with an undo operation.
     *
     * Truly scrambled boards are created by calling setTracker repeatedly.
     *
     * @see Board#setTracker
     * @param numRows is the number of tiles vertically
     * @param numCols is the number of tiles horizontally
     */
    public Board(int numRows, int numCols) {
    	this.numRows = numRows;
    	this.numCols = numCols;
    	moves = new ArrayList<>();
    	cursorI = 0;
    	cursorJ = 0;
    	trackers = new Tracker[numRows][numCols];
    	for(int i = 0; i <numRows; ++i) {
    		for(int j = 0; j < numCols; ++j) {
    			trackers[i][j] = new Tracker(i, j, i, j, 0, false);
    		}
    	}
    }

    /**
     * Determines whether the current Board represents a solved state.  There
     * are two possible solved states.  In the first solved state, every tile
     * is in C0, and is in the correct position -- meaning the tile with
     * correctI and correctJ is stored in the corresponding correctI and
     * correctJ positions of the Board.  In the second solved state, every
     * tile is in C0F, and each row is in the correct order from right to
     * left.  This means the solved picture is being looked at from the back,
     * or, is a mirror image of the original picture, but otherwise looks
     * completely normal (see the specification).
     *
     * @return true if the Board is solved, and false otherwise.
     */
    public boolean isSolved() {
    	boolean firstState = true;
    	boolean secondState = true;
    	
    	for(int i = 0; i < numRows; ++i) {
    		for(int j = 0; j < numCols; ++j) {
    			Tracker t = trackers[i][j];
    			if(t.getCorrectI() != i || t.getCorrectJ() != j || t.getRotations() != 0 || t.getIsFlipped()) {
    				  firstState = false;
    			}
    			
    			if(t.getCorrectI() != i || t.getCorrectJ() != (numCols - 1 -j) || t.getRotations() != 0 || !t.getIsFlipped()) {
    				secondState = false;
    			}
    			
    		}
    	}
    	return firstState || secondState;
    }

    /**
     * Given a tracker generated by a scrambling process (which is beyond the
     * scope of this assignment), store it in position (i, j).
     *
     * @param i the row index to store it in
     * @param j the column index to store it in
     * @param t the Tracker that should be stored
     */
    public void setTracker(int i, int j, Tracker t) {
    	trackers[i][j] = t;
    }

    /**
     * Return the tracker in a particular row i and column j, corresponding to
     * the tile that is in tile position i and j.
     *
     * @param i the row index to read from
     * @param j the column index to read from
     * @return the tracker at i, and j.
     */
    public Tracker getTracker(int i, int j) {
		return trackers[i][j];
    }

    /**
     * Get the number of rows on the board corresponding to the number of
     * tiles on the vertical side of the corresponding Picture.
     *
     * @return the number of rows.
     */
    public int getNumRows() {
		return numRows;
    }

    /**
     * Get the number of columns on the board corresponding to the number of
     * tiles on the horizontal side of the corresponding Picture.
     *
     * @return the number of columns.
     */
    public int getNumCols() {
		return numCols;
    }

    /**
     * Get the current row index of the cursor indicating the tile that will
     * be affected by any "stationary" operations that change the orientation
     * of the tile.
     *
     * @return the row index of the cursor.
     */
    public int getCursorI() {
		return cursorI;
    }

    /**
     * Get the current column index of the cursor indicating the tile that
     * will be affected by any "stationary" operations that change the
     * orientation of the tile.
     *
     * @return the column index of the cursor.
     */
    public int getCursorJ() {
		return cursorJ;
    }
    
    /**
     * Changes the position of the cursor by increasing the cursor's column
     * index by one, provided the cursor is not already on the rightmost
     * column.  If successful, the move should be recorded on the list of user
     * moves so that it can be undone later if desired.
     */
    public void moveRight() {
    	if(cursorJ < numCols - 1) {
    		cursorJ++;
    		moves.add("moveRight");
    	}
    }
    
    /**
     * Changes the position of the cursor by decreasing the cursor's column
     * index by one, provided the cursor is note already on the leftmost
     * column.  If successful, the move should be recorded on the list of user
     * moves so that it can be undone later if desired.
     */
    public void moveLeft() {
    	if(cursorJ > 0) {
    		cursorJ--;
    		moves.add("moveLeft");
    	}
    }
    
    /**
     * Changes the position of the cursor by increasing the cursor's row index
     * by one, provided the cursor is note already on the bottommost row.  If
     * successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void moveDown() {
    	if(cursorI < numRows - 1) {
    		cursorI++;
    		moves.add("moveDown");
    	}
    }
    
    /**
     * Changes the position of the cursor by decreasing the cursor's row
     * index by one, provided the cursor is note already on the topmost
     * row.  If successful, the move should be recorded on the list of user
     * moves so that it can be undone later if desired.
     */
    public void moveUp() {
    	if(cursorI > 0) {
    		cursorI--;
    		moves.add("moveUp");
    	}
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor to the right, and change the position of the cursor
     * by increasing the cursor's column index by one.  These actions are
     * performed only if the cursor is not already on the rightmost column.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapRight() {
    	if(cursorJ < numCols - 1) {
    		int currentRow = cursorI;
    		int targetCol= cursorJ + 1;
    		int currentCol = cursorJ;
    		Tracker tempTracker = trackers[currentRow][targetCol];
    		trackers[currentRow][targetCol] = trackers[currentRow][currentCol];
    		trackers[currentRow][currentCol] = tempTracker;
    		cursorJ++;
    		moves.add("swapRight");
    	}
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor to the left, and change the position of the cursor
     * by decreasing the cursor's column index by one.  These actions are
     * performed only if the cursor is not already on the leftmost column.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapLeft() {
    	if(cursorJ > 0) {
    		int currentRow = cursorI;
    		int targetCol = cursorJ - 1;
    		int currentCol = cursorJ;
    		Tracker tempTracker = trackers[currentRow][targetCol];
    		trackers[currentRow][targetCol] = trackers[currentRow][currentCol];
    		trackers[currentRow][currentCol] = tempTracker;
    		cursorJ--;
    		moves.add("swapLeft");
    	}
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor below, and change the position of the cursor by
     * increasing the cursor's row index by one.  These actions are
     * performed only if the cursor is not already on the bottommost row.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapDown() {
    	if(cursorI < numRows - 1) {
    		int currentRow = cursorI;
    		int targetRow = cursorI + 1;
    		int currentCol = cursorJ;
    		Tracker tempTracker = trackers[targetRow][currentCol];
    		trackers[targetRow][currentCol] = trackers[currentRow][currentCol];
    		trackers[currentRow][currentCol] = tempTracker;
    		cursorI++;
    		moves.add("swapDown");
    	}
    	
    }

    /**
     * Records that the user is swapping the tile at the cursor position
     * with its neighbor above, and change the position of the cursor by
     * decreasing the cursor's row index by one.  These actions are
     * performed only if the cursor is not already on the topmost row.
     * If successful, the move should be recorded on the list of user moves so
     * that it can be undone later if desired.
     */
    public void swapUp() {
    	if(cursorI > 0) {
    		int currentRow = cursorI;
    		int targetRow = cursorI - 1;
    		int currentCol = cursorJ;
    		Tracker tempTracker = trackers[targetRow][currentCol];
    		trackers[targetRow][currentCol] = trackers[currentRow][currentCol];
    		trackers[currentRow][currentCol] = tempTracker;
    		cursorI--;
    		moves.add("swapUp");
    	}
    }

    /**
     * Records that the user is turning the tile at the cursor position
     * clockwise.  This is always possible, and the move should be recorded
     * on the list of user moves so that it can be undone later if desired.
     */
    public void clockwise() {
    	Tracker t = trackers[cursorI][cursorJ];
    	t.clockwise();
    	moves.add("clockwise");
    }

    /**
     * Records that the user is turning the tile at the cursor position
     * anticlockwise.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void anticlockwise() {
    	Tracker t = trackers[cursorI][cursorJ];
    	t.anticlockwise();
    	moves.add("anticlockwise");
    }

    /**
     * Records that the user is performing an hflip on the tile at the
     * cursor position.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void hflip() {
    	Tracker t = trackers[cursorI][cursorJ];
    	t.hflip();
    	moves.add("hflip");
    }

    /**
     * Records that the user is performing an vflip on the tile at the
     * cursor position.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void vflip() {
    	Tracker t = trackers[cursorI][cursorJ];
    	t.vflip();
    	moves.add("vflip");
    }

    /**
     * Records that the user is performing a transpose on the tile at the
     * cursor position.  This is always possible, and the move should be
     * recorded on the list of user moves so that it can be undone later if
     * desired.
     */
    public void transpose() {
    	Tracker t = trackers[cursorI][cursorJ];
    	t.transpose();
    	moves.add("transpose");
    }

    /**
     * This undoes the most recent move on the list of user moves, by
     * performing its exact opposite action, and then removing the opposite
     * action as well as the undone action from the list of user moves.  The
     * undo move itself should not be recorded on the list of user moves.
     */
    public void undo() {
    	Tracker t = trackers[cursorI][cursorJ];
    	if(moves.isEmpty()) {
    		return;
    	}
    	
    	String lastMove = moves.remove(moves.size() - 1);
    	
    	if(lastMove.equals("moveRight")) {
    		if(cursorJ > 0) {
    			cursorJ--;
    		}
    	}
    	else if(lastMove.equals("moveLeft")) {
    		if(cursorJ < numCols -1) {
    			cursorJ++;
    		}
    	}
    	else if(lastMove.equals("moveDown")) {
    		if(cursorI > 0) {
    			cursorI--;
    		}
    	}
    	else if(lastMove.equals("moveUp")) {
    		if(cursorI < numRows - 1) {
    			cursorJ++;
    		}
    	}
    	else if(lastMove.equals("swapRight")) {
            if(cursorJ > 0) {
                int currentRow = cursorI;
                int targetCol = cursorJ - 1;
                int currentCol = cursorJ;
                Tracker tempTracker = trackers[currentRow][targetCol];
                trackers[currentRow][targetCol] = trackers[currentRow][currentCol];
                trackers[currentRow][currentCol] = tempTracker;
                cursorJ--;
            }
        }
    	else if(lastMove.equals("swapLeft")) {
            if(cursorJ < numCols - 1) {
                int currentRow = cursorI;
                int targetCol = cursorJ + 1;
                int currentCol = cursorJ;
                Tracker tempTracker = trackers[currentRow][targetCol];
                trackers[currentRow][targetCol] = trackers[currentRow][currentCol];
                trackers[currentRow][currentCol] = tempTracker;
                cursorJ++;
            }
    	}
    	else if(lastMove.equals("swapDown")) {
            if(cursorI > 0) {
                int currentRow = cursorI;
                int targetRow = cursorI - 1;
                int currentCol = cursorJ;
                Tracker tempTracker = trackers[targetRow][currentCol];
                trackers[targetRow][currentCol] = trackers[currentRow][currentCol];
                trackers[currentRow][currentCol] = tempTracker;
                cursorI--;
            }
        }
    	else if(lastMove.equals("swapUp")) {
            if(cursorI < numRows - 1) {
                int currentRow = cursorI;
                int targetRow = cursorI + 1;
                int currentCol = cursorJ;
                Tracker tempTracker = trackers[targetRow][currentCol];
                trackers[targetRow][currentCol] = trackers[currentRow][currentCol];
                trackers[currentRow][currentCol] = tempTracker;
                cursorI++;
            }
        }
    	else if(lastMove.equals("clockwise")) {
            t.anticlockwise();
        }
    	else if(lastMove.equals("anticlockwise")) {
            t.clockwise();
        }
    	 else if(lastMove.equals("hflip")) {
	        t.hflip();
	    }
	    else if(lastMove.equals("vflip")) {
	        t.vflip();
	    }
	    else if(lastMove.equals("transpose")) {
	        t.transpose();
	    }
    	
    }

    /**
     * Convert the internal state of the entire Board object into the form of
     * a string, including (in this order):
     *
     * - the number of rows on the board, followed by a newline
     * - the number of columns on the board, followed by a newline
     * - the cursor row position, followed by a newline
     * - the cursor column position, followed by a newline
     * - a one line description of each Tracker on the board, reading row by
     *   row in the board (and left to right in each row).  The one-line
     *   description (without its corresponding newline character) must be one
     *   which can be used to initialize a Tracker directly.
     * - a list of all the moves the user has made so far while solving the
     *   puzzle, with each move followed by a newline
     *
     * @return the string representation of the board
     */
    public String save() {
    	String result = "";
    	result += numRows + "\n";
    	result += numCols + "\n";
    	result += cursorI + "\n";
    	result += cursorJ + "\n";
    	
    	for(int i = 0; i < numRows; ++i) {
    		for(int j = 0; j < numCols; ++j) {
    			result += trackers[i][j].toString() + "\n";
    		}
    	}
    	
    	for(String move : moves) {
    		result += move + "\n";
    	}
		return result;
    }

    /**
     * Initialize the internal state of this Board object from the fromString.
     *
     * @see Board#save
     * @param fromString describes in a string format the state of the Board
     *                   object which should be constructed.
     */
    public void load(String fromString) {
    	String[] lines = fromString.split("\n");
    	int lineIndex = 0;
    	numRows = Integer.parseInt(lines[lineIndex++]);
    	numCols = Integer.parseInt(lines[lineIndex++]);
    	cursorI = Integer.parseInt(lines[lineIndex++]);
    	cursorJ = Integer.parseInt(lines[lineIndex++]);
    	
    	//Recreates the trackers array
    	trackers = new Tracker[numRows][numCols];
    	for(int i = 0; i < numRows; ++i) {
    		for(int j = 0; j < numCols; ++j) {
    			trackers[i][j] = new Tracker(lines[lineIndex++]);
    		}
    	}
    	
    	//Recreates the moves list
    	moves = new ArrayList<>();
    	while(lineIndex < lines.length) {
    		String line = lines[lineIndex++].trim();
    		if(!line.isEmpty()) {
    			moves.add(line);
    		}
    	}
    }
}
